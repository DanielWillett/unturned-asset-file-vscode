using DanielWillett.UnturnedDataFileLspServer.Data.Properties;
using DanielWillett.UnturnedDataFileLspServer.Data.Utility;
using System;

namespace DanielWillett.UnturnedDataFileLspServer.Data.Types;

/// <summary>
/// Any defined type, such as assets, objects, and enums.
/// <para>
/// Primary implementations:
/// <list type="bullet">
///    <item><see cref="AssetSpecType"/></item>
///    <item><see cref="EnumSpecType"/></item>
///    <item><see cref="CustomSpecType"/></item>
/// </list>
/// </para>
/// </summary>
public interface ISpecType : IEquatable<ISpecType?>, IAdditionalPropertyProvider
{
    /// <summary>
    /// Parent type from which this type inherits all properties.
    /// </summary>
    QualifiedType Parent { get; }

    /// <summary>
    /// Assembly-qualified type name of this type.
    /// </summary>
    QualifiedType Type { get; }

    /// <summary>
    /// Human-readable name of this type.
    /// </summary>
    string DisplayName { get; }

    /// <summary>
    /// Link to the U3 modding documentation for this file type.
    /// </summary>
    string? Docs { get; }

    /// <summary>
    /// Game version that this type was added in.
    /// </summary>
    Version? Version { get; }

    AssetSpecType Owner { get; set; }

    /// <summary>
    /// Perform a na√Øve search for a property by it's key. Doesn't support template properties or aliases.
    /// </summary>
    SpecProperty? FindProperty(string propertyName, SpecPropertyContext context);
}

/// <summary>
/// Any defined type with properties, such as objects and assets.
/// <para>
/// Primary implementations:
/// <list type="bullet">
///    <item><see cref="AssetSpecType"/></item>
///    <item><see cref="CustomSpecType"/></item>
/// </list>
/// </para>
/// </summary>
public interface IPropertiesSpecType : ISpecType
{
    /// <summary>
    /// Properties that should be present in the asset (or main) file.
    /// </summary>
    SpecProperty[] Properties { get; set; }

    /// <summary>
    /// Properties that should be present in the localization file, if any.
    /// </summary>
    SpecProperty[] LocalizationProperties { get; set; }

    /// <summary>
    /// Indicates that keys were generated from Variable names, meaning every Variable will be equal to their keys.
    /// </summary>
    bool AutoGeneratedKeys { get; }

    /// <summary>
    /// Indicates that it is valid for properties to have no value, meaning they fall back to the default values.
    /// </summary>
    /// <remarks>This is used by the new server configuration.</remarks>
    bool OverridableProperties { get; }

    /// <summary>
    /// Assets that should be present in the masterbundle folder for this asset, if any.
    /// </summary>
    SpecBundleAsset[] BundleAssets { get; set; }
}

public static class SpecTypeExtensions
{
    public static SpecProperty[] GetProperties(this ISpecType specType, SpecPropertyContext context)
    {
        return context switch
        {
            SpecPropertyContext.Property or SpecPropertyContext.CrossReferenceProperty
                => (specType as IPropertiesSpecType)?.Properties ?? Array.Empty<SpecProperty>(),
            SpecPropertyContext.Localization or SpecPropertyContext.CrossReferenceLocalization
                => (specType as IPropertiesSpecType)?.LocalizationProperties ?? Array.Empty<SpecProperty>(),
            // ReSharper disable CoVariantArrayConversion
            SpecPropertyContext.BundleAsset
                => (specType as IPropertiesSpecType)?.BundleAssets ?? Array.Empty<SpecBundleAsset>(),
            // ReSharper restore CoVariantArrayConversion
            _ => throw new ArgumentOutOfRangeException(nameof(context))
        };
    }

    public static void SetProperties(this ISpecType specType, SpecProperty[] properties, SpecPropertyContext context)
    {
        switch (context)
        {
            case SpecPropertyContext.CrossReferenceProperty:
            case SpecPropertyContext.Property:
                if (specType is IPropertiesSpecType st)
                    st.Properties = properties;
                break;

            case SpecPropertyContext.CrossReferenceLocalization:
            case SpecPropertyContext.Localization:
                if (specType is IPropertiesSpecType st2)
                    st2.LocalizationProperties = properties;
                break;

            // ReSharper disable CoVariantArrayConversion
            case SpecPropertyContext.BundleAsset:
                if (specType is IPropertiesSpecType st3)
                    st3.BundleAssets = (SpecBundleAsset[])properties;
                break;

            default:
                // ReSharper restore CoVariantArrayConversion
                throw new ArgumentOutOfRangeException(nameof(context));
        }
    }
}