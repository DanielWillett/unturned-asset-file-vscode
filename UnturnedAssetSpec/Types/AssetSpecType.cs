using DanielWillett.UnturnedDataFileLspServer.Data.Properties;
using DanielWillett.UnturnedDataFileLspServer.Data.TypeConverters;
using DanielWillett.UnturnedDataFileLspServer.Data.Utility;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Text.Json.Serialization;

namespace DanielWillett.UnturnedDataFileLspServer.Data.Types;

/// <summary>
/// An object type used to represent file types.
/// </summary>
/// <remarks>While these are usually asset types, some other types are defined in this way such as <c>MasterBundleConfig</c>.</remarks>
[JsonConverter(typeof(AssetSpecTypeConverter))]
[DebuggerDisplay("Type: {Type.GetTypeName()}")]
public sealed class AssetSpecType : IPropertiesSpecType, IEquatable<AssetSpecType?>, ISpecPropertyType<CustomSpecTypeInstance>
{
    /// <summary>
    /// The GitHub commit (SHA) where this information was taken from, if any. Note that some information may have been pulled from other places.
    /// </summary>
    public string? Commit { get; set; }

    /// <summary>
    /// Assembly-qualified type name of this type.
    /// </summary>
    public QualifiedType Type { get; internal set; }

    /// <inheritdoc />
    public bool AutoGeneratedKeys { get; set; }

    /// <inheritdoc />
    public bool OverridableProperties { get; set; }

    /// <inheritdoc />
    public Type ValueType => typeof(CustomSpecTypeInstance);

    /// <inheritdoc />
    public SpecPropertyTypeKind Kind => SpecPropertyTypeKind.Class;

    /// <inheritdoc />
    public bool TryParseValue(in SpecPropertyTypeParseContext parse, out ISpecDynamicValue value)
    {
        if (!TryParseValue(in parse, out CustomSpecTypeInstance? inst) || inst == null)
        {
            value = null!;
            return false;
        }

        value = inst;
        return true;
    }

    /// <inheritdoc />
    public void Visit<TVisitor>(ref TVisitor visitor) where TVisitor : ISpecPropertyTypeVisitor
    {
        visitor.Visit(this);
    }

    public EnumSpecTypeValue Category { get; set; } = AssetCategory.None;

    /// <summary>
    /// Link to the U3 modding documentation for this file type.
    /// </summary>
    public string? Docs { get; set; }

    /// <summary>
    /// Parent type from which this type inherits all properties.
    /// </summary>
    public QualifiedType Parent { get; set; }

    /// <summary>
    /// Minimum ID for modded items.
    /// </summary>
    public ushort VanillaIdLimit { get; set; }

    /// <summary>
    /// Whether or not this type of asset must have an ID to function correctly.
    /// </summary>
    public bool RequireId { get; set; }

    /// <summary>
    /// Human-readable name of this type.
    /// </summary>
    public string DisplayName { get; set; } = string.Empty;

    /// <inheritdoc />
    string ISpecPropertyType.Type => Type.Type;

    /// <summary>
    /// Game version that this type was added in.
    /// </summary>
    public Version? Version { get; set; }

    /// <summary>
    /// Any additional JSON properties that don't have their own property.
    /// </summary>
    public OneOrMore<KeyValuePair<string, object?>> AdditionalProperties { get; set; } = OneOrMore<KeyValuePair<string, object?>>.Null;

#nullable disable
    /// <summary>
    /// All properties that should be present in the asset (or main) file.
    /// </summary>
    public SpecProperty[] Properties { get; set; }

    /// <summary>
    /// All properties that should be present in the localization file, if any.
    /// </summary>
    public SpecProperty[] LocalizationProperties { get; set; }

    /// <summary>
    /// All assets that should be present in the masterbundle folder for this asset, if any.
    /// </summary>
    public SpecBundleAsset[] BundleAssets { get; set; }

    /// <summary>
    /// Any other types defined in the file relevant to either this type or the types that inherit this type.
    /// </summary>
    /// <remarks>This could include enums used by properties, object types like Blueprints, etc.</remarks>
    public ISpecType[] Types { get; set; }
#nullable restore

    AssetSpecType ISpecType.Owner { get => this; set => throw new NotSupportedException(); }

    /// <summary>
    /// Temporarily add a property for unit test purposes.
    /// </summary>
    internal IDisposable AddRootPropertyForTest(SpecPropertyContext context, SpecProperty property)
    {
        SpecProperty[] props = this.GetProperties(context);

        SpecProperty[] newArray = new SpecProperty[props.Length + 1];
        newArray[^1] = property;
        Array.Copy(props, 0, newArray, 0, props.Length);
        this.SetProperties(newArray, context);
        return new AddedTestProperty(this, property, context);
    }

    private class AddedTestProperty(AssetSpecType type, SpecProperty property, SpecPropertyContext context) : IDisposable
    {
        public void Dispose()
        {
            SpecProperty[] props = type.GetProperties(context);

            int index = Array.IndexOf(props, property);
            if (index < 0)
                return;

            SpecProperty[] newArray = new SpecProperty[props.Length - 1];
            Array.Copy(props, 0, newArray, 0, index);
            Array.Copy(props, index + 1, newArray, index, props.Length - (index + 1));
            type.SetProperties(newArray, context);
        }
    }

    /// <inheritdoc />
    public bool Equals(AssetSpecType? other)
    {
        if (other == null)
            return false;

        return !Type.Equals(other.Type)
            || !Category.Equals(other.Category)
            || !string.Equals(Docs, other.Docs, StringComparison.Ordinal)
            || !Parent.Equals(other.Parent)
            || VanillaIdLimit != other.VanillaIdLimit
            || RequireId != other.RequireId
            || OverridableProperties != other.OverridableProperties
            || AutoGeneratedKeys != other.AutoGeneratedKeys
            || !string.Equals(DisplayName, other.DisplayName, StringComparison.Ordinal)
            || !EquatableArray.EqualsEquatable(Properties, other.Properties)
            || !EquatableArray.EqualsEquatable(LocalizationProperties, other.LocalizationProperties)
            || !EquatableArray.EqualsEquatable(BundleAssets, other.BundleAssets)
            || !EquatableArray.EqualsEquatable(Types, other.Types);
    }

    /// <inheritdoc />
    public bool Equals(ISpecType? other) => other is AssetSpecType t && Type.Equals(t.Type);

    /// <inheritdoc />
    public bool Equals(ISpecPropertyType? other) => other is AssetSpecType t && Equals(t);

    /// <inheritdoc />
    public bool Equals(ISpecPropertyType<CustomSpecTypeInstance>? other) => other is AssetSpecType t && Equals(t);

    /// <inheritdoc />
    public override bool Equals(object? obj) => obj is AssetSpecType ti && Equals(ti);

    /// <inheritdoc />
    public override int GetHashCode()
    {
        // ReSharper disable once NonReadonlyMemberInGetHashCode
        return Type.GetHashCode();
    }

    /// <inheritdoc />
    public override string ToString() => Type.ToString();

    /// <summary>
    /// Perform a na√Øve search for a property by it's key. Doesn't support template properties or aliases.
    /// </summary>
    public SpecProperty? FindProperty(string propertyName, SpecPropertyContext context)
    {
        if (Properties != null && context is SpecPropertyContext.Property or SpecPropertyContext.Unspecified)
        {
            foreach (SpecProperty property in Properties)
            {
                if (property.Key.Equals(propertyName, StringComparison.OrdinalIgnoreCase))
                    return property;
            }
        }
        if (LocalizationProperties != null && context is SpecPropertyContext.Localization or SpecPropertyContext.Unspecified)
        {
            foreach (SpecProperty property in LocalizationProperties)
            {
                if (property.Key.Equals(propertyName, StringComparison.OrdinalIgnoreCase))
                    return property;
            }
        }

        return null;
    }

    /// <inheritdoc />
    public bool TryParseValue(in SpecPropertyTypeParseContext parse, out CustomSpecTypeInstance? value)
    {
        // todo
        value = null;
        return false;
    }

    /// <inheritdoc />
    public ISpecDynamicValue CreateValue(CustomSpecTypeInstance? value)
    {
        return value == null ? SpecDynamicValue.Null : new SpecDynamicConcreteValue<CustomSpecTypeInstance>(value, this);
    }
}