using DanielWillett.UnturnedDataFileLspServer.Data.Properties;
using System;
using System.Collections.Immutable;
using System.Text.Json;

namespace DanielWillett.UnturnedDataFileLspServer.Data.Spec;

partial class SpecificationFileReader
{
    private JsonElement _typeRoot;
    private int _currentTypeIndex;

    private DatFileType ReadFileType(JsonDocument doc, QualifiedType fileType)
    {
        JsonElement root = doc.RootElement;

        // check that type is correct
        if (root.TryGetProperty("Type"u8, out JsonElement element))
        {
            AssertValueKind(in element, fileType, JsonValueKind.String);
            if (!element.ValueEquals(fileType.Type.AsSpan()))
                throw new JsonException(string.Format(Resources.JsonException_InvalidTypeInDatFileType, element.GetString(), fileType.GetFullTypeName()), "Type", null, null);
        }

        // get parent type from JSON
        DatFileType? parentType = null;
        if (root.TryGetProperty("Parent"u8, out element))
        {
            string? parentTypeStr = element.GetString();
            if (parentTypeStr != null)
            {
                QualifiedType qualifiedType = new QualifiedType(parentTypeStr, isCaseInsensitive: true);
                _fileTypeBuilder?.TryGetValue(qualifiedType, out parentType);
            }
        }

        bool isAsset = _readInformation != null && _readInformation.IsAssignableFrom(QualifiedType.AssetBaseType, fileType.Type);

        DatFileType type = DatType.CreateFileType(fileType, isAsset, root, parentType);

        _fileTypeBuilder?[fileType] = type;

        if (type is DatAssetFileType assetType)
        {
            // Category
            if (root.TryGetProperty("Category"u8, out element) && element.ValueKind != JsonValueKind.Null)
                assetType.Category = new AssetCategoryValue(element.GetString()!);
            else
                assetType.Category = AssetCategoryValue.None;

            // VanillaIdLimit
            if (root.TryGetProperty("VanillaIdLimit"u8, out element) && element.ValueKind != JsonValueKind.Null)
            {
                ushort id = element.GetUInt16();
                assetType.VanillaIdLimit = id == 0 ? null : id;
            }
            else
                assetType.VanillaIdLimit = null;
            
            // RequireId
            if (root.TryGetProperty("RequireId"u8, out element) && element.ValueKind != JsonValueKind.Null)
                assetType.RequireId = element.GetBoolean();
        }

        // DisplayName
        if (root.TryGetProperty("DisplayName"u8, out element) && element.ValueKind != JsonValueKind.Null)
        {
            type.DisplayNameIntl = element.GetString()!;
            if (type.DisplayNameIntl.Length == 0)
                type.DisplayNameIntl = type.TypeName.GetFullTypeName();
        }
        else
        {
            type.DisplayNameIntl = type.TypeName.GetFullTypeName();
        }

        // Docs
        if (root.TryGetProperty("Docs"u8, out element))
            type.Docs = element.GetString();
        
        // Version
        if (root.TryGetProperty("Version"u8, out element) && element.ValueKind != JsonValueKind.Null)
            type.Version = Version.Parse(element.GetString()!);
        
        // AutoGeneratedKeys
        if (root.TryGetProperty("AutoGeneratedKeys"u8, out element) && element.ValueKind != JsonValueKind.Null)
            type.AutoGeneratedKeys = element.GetBoolean();

        // OverridableProperties
        if (root.TryGetProperty("OverridableProperties"u8, out element) && element.ValueKind != JsonValueKind.Null)
            type.OverridableProperties = element.GetBoolean();

        if (root.TryGetProperty("Types"u8, out element) && element.ValueKind != JsonValueKind.Null)
        {
            _typeRoot = element;
            AssertValueKind(in element, fileType, JsonValueKind.Array);
            int typeCount = element.GetArrayLength();
            ImmutableDictionary<QualifiedType, DatType>.Builder typeDictionaryBuilder = ImmutableDictionary.CreateBuilder<QualifiedType, DatType>();
            type.TypesBuilder = typeDictionaryBuilder;

            for (int i = 0; i < typeCount; ++i)
            {
                _currentTypeIndex = i;
                ReadTypeFirstPass(in element, i, typeDictionaryBuilder, type);
            }

            type.Types = typeDictionaryBuilder.ToImmutable();
            type.TypesBuilder = null;
            _typeRoot = default;
        }

        if (root.TryGetProperty("Properties"u8, out element) && element.ValueKind != JsonValueKind.Null)
        {
            AssertValueKind(in element, fileType, JsonValueKind.Array);
            int propertyCount = element.GetArrayLength();

            ImmutableArray<DatProperty>.Builder propertyBuilder = ImmutableArray.CreateBuilder<DatProperty>(propertyCount);

            for (int i = 0; i < propertyCount; ++i)
            {
                ReadPropertyFirstPass(in element, i, "Properties", t => t.Properties, propertyBuilder, SpecPropertyContext.Property, type);
            }

            type.Properties = propertyBuilder.ToImmutable();
        }

        return type;
    }

    private static void AssertValueKind(in JsonElement element, QualifiedType type, JsonValueKind kind)
    {
        if (element.ValueKind == kind)
            return;
        
        throw new JsonException(string.Format(Resources.JsonException_InvalidJsonToken, element.ValueKind, kind, type.GetFullTypeName()));
    }
}
