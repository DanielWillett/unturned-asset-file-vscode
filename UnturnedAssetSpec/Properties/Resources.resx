<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="ArgumentException_BaseTypeNotAllowedForEnums" xml:space="preserve">
    <value>Enums can not have a base type.</value>
  </data>
  <data name="ArgumentException_CasingValueLengthMismatch" xml:space="preserve">
    <value>Casing and value must have the same length.</value>
  </data>
  <data name="ArgumentException_CompositeFlagValue" xml:space="preserve">
    <value>Value list can not contain a value made up of other values.</value>
  </data>
  <data name="FormatException_Expression_ExpectedFunctionName" xml:space="preserve">
    <value>Expected function name at beginning of expression.</value>
  </data>
  <data name="FormatException_Expression_ExpectedFunctionStart" xml:space="preserve">
    <value>Expected end of expression or open parenthesis after function name.</value>
  </data>
  <data name="FormatException_Expression_ExpectedNextArgument" xml:space="preserve">
    <value>Expected end of expression or next argument after parameter closing.</value>
  </data>
  <data name="FormatException_Expression_ExpectedParenthesizedValueEnd" xml:space="preserve">
    <value>Expected closing parenthesis at end of value.</value>
  </data>
  <data name="FormatException_Expression_MissingEndingParenthesis" xml:space="preserve">
    <value>Parameter list not closed, expected ')'.</value>
  </data>
  <data name="FormatException_IPv4Format_FailedToParse" xml:space="preserve">
    <value>Failed to parse IPv4Filter, expected a value in the format: "0.0.0.0[/0][:0[-0]]".</value>
  </data>
  <data name="InvalidOperationException_InvalidCountType" xml:space="preserve">
    <value>Invalid count type: '{0}'. Expected an integer type.</value>
  </data>
  <data name="InvalidOperationException_InvalidVectorType" xml:space="preserve">
    <value>Invalid vector type: '{0}'. Annotate the type with a {1} to define a vector provider.</value>
  </data>
  <data name="JsonException_EnumMissingValue" xml:space="preserve">
    <value>Enum value "{0}" didn't define a value string.</value>
  </data>
  <data name="JsonException_FailedToParseEnum" xml:space="preserve">
    <value>Failed to parse enum of type {0} from value "{1}" in file "{2}".</value>
  </data>
  <data name="JsonException_FailedToParseValue" xml:space="preserve">
    <value>Failed to parse value of type "{0}" in file "{1}".</value>
  </data>
  <data name="JsonException_FailedToReadValue" xml:space="preserve">
    <value>Unable to read value of type {0} from JSON at {1}.</value>
  </data>
  <data name="JsonException_FlagEnumMissingNumericValue" xml:space="preserve">
    <value>Flag enum value "{0}" did not define a numeric value, which is required for flag enum values.</value>
  </data>
  <data name="JsonException_InvalidJsonToken" xml:space="preserve">
    <value>Unexpected token "{0}" while reading file "{1}".</value>
  </data>
  <data name="JsonException_InvalidTypeInDatFileType" xml:space="preserve">
    <value>"Type" property was set to "{0}" in the file type definition for "{1}".</value>
  </data>
  <data name="JsonException_OverriddenPropertyNotFound" xml:space="preserve">
    <value>Unable to find a property named "{0}" in any parent types to override in file "{1}".</value>
  </data>
  <data name="JsonException_ParentTypeNotFound" xml:space="preserve">
    <value>Unable to locate parent type "{0}" for type "{1}".</value>
  </data>
  <data name="JsonException_PropertyKeyMissing" xml:space="preserve">
    <value>Property "{0}" doesn't define a key, which is required.</value>
  </data>
  <data name="JsonException_PropertyTypeMissing" xml:space="preserve">
    <value>Property "{0}" doesn't define a type, which is required unless the property is updating/hiding a base property.</value>
  </data>
  <data name="JsonException_PropertyTypeNotFound" xml:space="preserve">
    <value>Unknown type "{0}" for property "{1}".</value>
  </data>
  <data name="JsonException_RequiredTypePropertyMissing" xml:space="preserve">
    <value>Required property "{0}" for type "{1}" missing in file "{2}".</value>
  </data>
  <data name="JsonException_TypeMissingTypeName" xml:space="preserve">
    <value>Type "{0}" does not define a "Type" property with a type name.</value>
  </data>
  <data name="Log_FailedToDownloadInternetResource" xml:space="preserve">
    <value>Unable to download internet resource at "{0}".</value>
  </data>
  <data name="Log_FailedToFindEmbeddedResource" xml:space="preserve">
    <value>Unable to locate embedded resource "{0}", which was expected to exist.</value>
  </data>
  <data name="Log_FailedToParseResource" xml:space="preserve">
    <value>Unable to read resource at "{0}".</value>
  </data>
  <data name="Log_FailedToReadAssetFile" xml:space="preserve">
    <value>Unable to read specification for type "{0}". This type and all child types will be skipped.</value>
  </data>
  <data name="Log_FailedToReadCommitHashFromRepo" xml:space="preserve">
    <value>Unable to read latest commit hash from GitHub API. They may have changed their API or the current network is being blocked.</value>
  </data>
  <data name="Log_InternetResourceCorrupted" xml:space="preserve">
    <value>Internet resource at "{0}" is corrupted.</value>
  </data>
  <data name="Log_UnableToReadFile" xml:space="preserve">
    <value>Unable to read file "{0}" from any of the available sources.</value>
  </data>
  <data name="Type_Name_AudioReference" xml:space="preserve">
    <value>Audio Reference</value>
  </data>
  <data name="Type_Name_Boolean" xml:space="preserve">
    <value>Boolean</value>
  </data>
  <data name="Type_Name_BooleanOrFlag" xml:space="preserve">
    <value>Boolean or Flag</value>
  </data>
  <data name="Type_Name_Character" xml:space="preserve">
    <value>Character</value>
  </data>
  <data name="Type_Name_ContentReference" xml:space="preserve">
    <value>Content Reference</value>
  </data>
  <data name="Type_Name_Flag" xml:space="preserve">
    <value>Flag</value>
  </data>
  <data name="Type_Name_Float32" xml:space="preserve">
    <value>Single-Precision Decimal</value>
  </data>
  <data name="Type_Name_Float64" xml:space="preserve">
    <value>Double-Precision Decimal</value>
  </data>
  <data name="Type_Name_Float128" xml:space="preserve">
    <value>Decimal</value>
  </data>
  <data name="Type_Name_Int8" xml:space="preserve">
    <value>Signed 8-Bit Integer</value>
  </data>
  <data name="Type_Name_Int16" xml:space="preserve">
    <value>Signed 16-Bit Integer</value>
  </data>
  <data name="Type_Name_Int32" xml:space="preserve">
    <value>Signed 32-Bit Integer</value>
  </data>
  <data name="Type_Name_Int64" xml:space="preserve">
    <value>Signed 64-Bit Integer</value>
  </data>
  <data name="Type_Name_List_Generic" xml:space="preserve">
    <value>List of {0}</value>
  </data>
  <data name="Type_Name_MasterBundleOrContentReference" xml:space="preserve">
    <value>Masterbundle or Content Reference</value>
  </data>
  <data name="Type_Name_MasterBundleReference" xml:space="preserve">
    <value>Masterbundle Reference</value>
  </data>
  <data name="Type_Name_MasterBundleReferenceString" xml:space="preserve">
    <value>Masterbundle Reference (Legacy)</value>
  </data>
  <data name="Type_Name_RegEx" xml:space="preserve">
    <value>Regular Expression (RegEx)</value>
  </data>
  <data name="Type_Name_String" xml:space="preserve">
    <value>Text</value>
  </data>
  <data name="Type_Name_TranslationReference" xml:space="preserve">
    <value>Legacy Translation Token Reference</value>
  </data>
  <data name="Type_Name_UInt8" xml:space="preserve">
    <value>Unsigned 8-Bit Integer</value>
  </data>
  <data name="Type_Name_UInt16" xml:space="preserve">
    <value>Unsigned 16-Bit Integer</value>
  </data>
  <data name="Type_Name_UInt32" xml:space="preserve">
    <value>Unsigned 32-Bit Integer</value>
  </data>
  <data name="Type_Name_UInt64" xml:space="preserve">
    <value>Unsigned 64-Bit Integer</value>
  </data>
  <data name="Type_Name_Vector2_Unspecified" xml:space="preserve">
    <value>2D Vector</value>
  </data>
  <data name="Type_Name_Vector3_Position" xml:space="preserve">
    <value>3D Position</value>
  </data>
  <data name="Type_Name_Vector3_Rotation" xml:space="preserve">
    <value>3D Euler Rotation</value>
  </data>
  <data name="Type_Name_Vector3_Scale" xml:space="preserve">
    <value>3D Scale</value>
  </data>
  <data name="Type_Name_Vector3_Unspecified" xml:space="preserve">
    <value>3D Vector</value>
  </data>
  <data name="Type_Name_Vector4_Quaternion" xml:space="preserve">
    <value>Quaternion</value>
  </data>
  <data name="Type_Name_Vector4_Unspecified" xml:space="preserve">
    <value>4D Vector</value>
  </data>
</root>